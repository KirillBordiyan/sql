понятие транзакции, св-ва ACID
понятие временной таблицы
переменные 
операторы IF, WHILE


Транзакция - набор инструкций, объед в одну логическую единицу
делятся на 2 типа:
неявные - которые предусмотрены на уровне БД. Например, БД задает отдельную инструкцию INSERT, UPDATE или DELete как единицу транзакции
явные - начало и конец явно обозначаются такими инструкциями как BEGIN TRANSACTION, COMMIT, ROLLBACK


A - атамарность, либо будут выполнены все действия, либо не будут выполнены вовсе
C - согласованность consistency, данные как пришли, так и вышли
I - изоляция isolation, 1эф - потерянное обновление, когда не учитывается изменение св-в, 2эф - грязное чтение - когда данные не были зафиксированны, 3эф-т - неповторимого чтения, когда считаем одну строку и фиксируем изменения (напрмиер, при снятии со счета, где 0, он уйдет в минус), 4эф - фантомное чтение, когда запрос делает несколько действий сразу, как бы независимо друг от друга
D - долговечность durability, если тр-я выполнена, то данные о выполнении будут сохранены, даже если будет сбой в системе


Решение эффектов, по уровням изоляции:
Read uncommited - фиксит эф-т потерянного обновления (1)
Read commited - RU + эф-т грязного чтения (1, 2)
Repeatable read - RC + эф-т неповторяемого чтения (1, 2, 3)
Serializable - решение всех 4х эффектов, работает так, будто во время выполнения транзации других транзакций не существует 


START TRANSACTION; //начинаем транзакцию
SELECT total FROM acc WHERE user_id = 2; //находим
UPDATE acc SET total = total -3000 WHERE user_id = 2; //снимаем средства
UPDATE acc SET total = total + 3000 WHERE user_id IS NULL; //переносим их на счет магазина
COMMIT; //коммитим


временные таблицы:
CREARE TEMPORARY TABLE name(
col1_def,
col2_def..
);

переменные 
SET @variable_name := value;
SET @counter := 100;

Select @var := val;

например
SELECT @max := MAX(price) FROM prod;


Оператор IF
IF(expr, if_true, if_false);
SELECT IF(400<2000, "YES", "NO"); // yes
SELECT IF(1 = 2, "true", "false"); //false


IF можно использовать с агрегатными функциями
SUM(IF(status = 'canc', 1, 0)) AS cancel;

Оператор COUNT IF:
SELECT DISTINCT
	status
FROM
	orders
ORDER BY status;





Процедуры:
процедура - функция, ничего не возвращает
CREATE PROCEDURE name [(par datatype [, par datatype]) ]
BEGIN
	dec_sect
	exec_sect
END;

IN - параметр может ссылаться на процедуру, значение не может быть перезаписано ею
OUT - не может ссылаться на процедуру, но значение может быть перезаписано ею
IN OUT - может ссылаться и значение может быть перезаписано
dec_sect - место, где объявл локальные переменные
exec_sect - место, в котором создается код процедуры


Теперь WHILE
[label_name] WHILE condition DO
{statements}
END WHILE [lab_name];
lab_name - имя, необязательное
cond - условие, приверяется пр икаждой итерации
state- исполняемый код























































