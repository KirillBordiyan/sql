групповые функции без сортировки
использование сортировки в оконной функции
ф-и ранжирования, получения значений из соседних строк
ф-и смещения и аналитические ф-ии
представления (view) - использование, операции с ними




вспоминаем агрегатные:
SELECT SUM(sale) FROM sales;
SELECT fin_y, SUM(sale) FROM sales
GROUP BY fin_y; , например

если такие примеры - одно целое, то оконные функции представляют 
из себя что-то вроде набора подзапросов
синтаксис:

SELECT название функции (столбцы)
OVER
(
	PARTITION BY столбец для группировки
	ORDER BY столбец для сортировки
	ROWS или RANGE выр-е для ограничения строк в пределах группы
)
FROM таблица;


оконные функции можно разделить на:
агрегатные (aggregate)
ранжирующие (ranking)
ф-ии смещения (Value)

Агрегатные, вспоминаем:
sum
count
avg
max
min

их можно совмещать с оконными:
SELECT Date, Conv, SUM(Conv) OVER(PARTITION BY Date) AS 'Sum',
COUNT(Conv) OVER(PARTITION BY Date) AS 'Count',
AVG(Conv) OVER(PARTITION BY Date) AS 'Avg' и тд 
FROM Orders;
в итоге получим таблицу сгруппированную по сталбцу "дата", где будут доп столбцы этих агрегатных функций
результат которых будет записан в каждую строку


Ранжирующие функции:
ROW_NUMBER - ф-я возвращает номер строки и используется для нумерации
RANK - ф-я возвращает ранг каждой строки. В данном случае значения уже анализируются и в случае нахождения одинаковых возвращает одинаковый ранг с пропуском следующего значения
DENSE_RANK- ф-я возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий
NTILE - ф-я возволяет определить к какой группе относится текущая строка, кол-во групп задается в скобках 

отличие RANKов в том, что при первом, выдав 1 и встречая такое же значение, выдаст 3, а не 2
а второй RANK как раз-таки выдаст 2, так как не пропускает ничего 


напрмиер:
SELECT date, conv
ROW_NUMBER() OVER(PARTITION BY date ORDER BY Conv) AS 'row_number',
RANK() OVER(PARTITION BY date ORDER BY Conv) AS 'rank',
DENSE_RANK() OVER(PARTITION BY date ORDER BY Conv) AS 'dense_rank',
NITLE(3) OVER(PARTITION BY date ORDER BY Conv) AS 'ntile'
FROM Orders;


в результате получим таблицу с нашими полями, сгруппированными в группы по дате + новыми обозначенными, где:
-в row_number будет задан номер строки в текущей группе
-в rank будут написаны ранги строк на основе Conv: если значение уже было- ставится тот же ранг, а новое +1
-в dense_rank будут описаны ранги строк без пропусков значений
-в ntile предположительное разделение на группы каких-то возможных вариантов событий,
	если при группировке по дате в каждой из групп было по 3 строки и в ntile задаем 3, то будет у каждой по отдельности
	если меньше, чем в ntile, то по кол-ву возможных
	если больше - будет автоматическое включение чего-то в уже существующую группу, но больше заданного кол-ва ntile групп не будет 



Ф-ии смещения:
LAG или LEAD - ф-я Lag  обращается к данным из предыдущей строки окна, а LEAD к данным из следующей строки.
Функцию можно использовать для того, чтобы стравнивать текущее значение строки с предыдущим или следующим.
Имеет три параметра: столбец, значение которого необходимо вернуть, кол-во строк для смещения (по умолчанию 1),
значение, которое необходимо вернуть если после смещения возвращается значение NULL

FIRST_VALUE или LAST_VALUE - с помощью ф-ии можно получить первое и последнее значение в окне.
В кач-ве параметра принимает столбец, значение которого необходимо вернуть.

написав запрос, подобный примерам выше, но вместо Conv - date 
получим наши сгруппированные столбцы + новые, по каждой функции описанной сейчас:
- в lag первая строка будет иметь null, тк перед ней ничего не было, вторая - значение первой и так до конца
- в lead наоборот, первая строка будет иметь значение второй (следующей), так до предпоследней, тк после последней нет строк, в ней будет NULL
- по сути lag и lead работают наоборот, крест-на-крест
-f_v и l_v будут отмечены первое и последнее значения в каждой конкретной группе


оставшаяся часть - аналитические, которые используются в высшей математике


Основное отличие оконных функций в том, что при выборке у нас НЕ СОКРАЩАЕТСЯ кол-во строк, а добавляется столбик

Порядок расчета оконных ф-й:
SELECT col, win_func
FROM table
WHERE condition
GROUP BY col
HAVING agg clause
ORDER BY col/win_func


Представления:
явл рез-м запроса к БД, виртуальная копия таблички
чтобы создать представление:
CREATE VIEW view_name AS 
SELECT col
FROM tabl
[WHERE condition];
	
например:
CREATE VIEW Londonstaff
	AS SELECT *
	FROM Salespeople
	WHERE city = 'London';
вывод - SELECT * FROM Londonstaff

удаление представление: DROP VIEW customer_archive;
Обхединение представлений: 
CREATE VIEW view-name AS 
SELECT col1, col2
FROM tabl1 INNER JOIN tabl2
ON tabl1.col = tabl2.col;


